# -*- coding: utf-8 -*-
"""Omics CNN T-test Ischemic_Stroke

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MLZWd17WAmsZNvrvcjLyUXVVWy17DUBi
"""

!pip install Biopython

!pip install bioinfokit

from google.colab import files 
uploaded = files.upload()

import pandas as pd
import io
ds=pd.read_excel(io.BytesIO(uploaded['combined_stroke_normalized - Αντιγραφή.xlsx']))
print(ds.shape)
print(ds.head())

from scipy import stats
import numpy as np
ds=np.transpose(ds)
data=np.array(ds.iloc[1:,1:])
columns=ds.iloc[0,1:]

ds=pd.DataFrame(data,columns=columns)
ds.head()

#T-TEST
df1=ds[ds['Results']=='stroke']
df2=ds[ds['Results']=='control']
l=[]
l2=[]
p_array=[]
l3=[]
listofgenes=[col for col in ds.columns if  (col!='Results')]
#print(listofgenes)
sunolo=0
list_values=[]
for x in listofgenes:
    #l.append(stats.ttest_ind(df1[x],df2[x], equal_var=False))
    tStat, pValue = stats.ttest_ind(df1[x],df2[x], equal_var=False)
    list_values.append(pValue)
    if(pValue<0.05):
      sunolo+=1
      l2.append(x)
      l3.append(x)
      p_array.append(pValue)
Z=[x for _,x in sorted(zip(p_array,l3))]

print(Z)
#print("P-values ",sorted(p_array))

data=[]

print(len(l2))
ds_new=np.transpose(ds)


for i in range (len(Z)):
  values=ds_new.loc[Z[i],:]
  data.append(values)

dataFrame=np.transpose(pd.DataFrame(data,Z))
print(dataFrame.shape)

dataFrame['Results']=ds_new.loc['Results',:]
outcome=dataFrame['Results']
dataFrame.head()

#export to excel

dataFrame.to_excel('Ichemic_Stroke_UpDownRegulated.xlsx', index = False,header=True)
files.download('Ichemic_Stroke_UpDownRegulated.xlsx')

from numpy.ma.core import append
import math
from bioinfokit import analys, visuz
value1=[]
value2=[]
log2FC=[]

geneNames=list(ds.columns.values)
geneNames.remove('Results')

#new_df= pd.DataFrame(dataFrame2.values[1:], columns=headers)
for gene in geneNames:
  x1=ds.loc[ds['Results']=='stroke',gene].mean()
  x2=ds.loc[ds['Results']=='control',gene].mean()
  value1.append(x1)
  value2.append(x2)
  if(x1==0):
    log2=0
  else:
    log2 = math.log2(x1/x2)
  log2FC.append(log2)


names3={'GRAP':'GRAP','ID3':'ID3','CD79B':'CD79B','ALKBH2':'ALKBH2','TNFRSF25':'TNFRSF25','WBSCR22':'WBSCR22','ELAC2':'ELAC2','SUSD3':'SUSD3','ABCA1':'ABCA1','MFGE8':'MFGE8','TR1B1':'TRIB1','SPIB':'SPIB','AARSD1':'AARSD1','IL23A':'IL23A','CD19':'CD19','TSPAN3':'TSPAN3','SAP30':'SAP30','ANKRD22':'ANKRD22','ARG1':'ARG1','ALKBH7':'ALKBH7','KIAA1958':'KIAA1958','CD72':'CD72','PFKP':'PFKP'}
list_of_genes_pvalue = list(zip(geneNames,list_values,value1,value2,log2FC))
df_genes = pd.DataFrame(list_of_genes_pvalue,columns = ['Name', 'P-value','value1','value2','log2FC']) 
visuz.GeneExpression.volcano(df=df_genes, lfc='log2FC', pv='P-value', lfc_thr=(0.0,0.0),pv_thr=(0.05,0.5),show=True,color=('green', 'grey', 'red'), plotlegend=True, legendpos='upper right',legendanchor=(1.46,1),geneid='Name',genenames=names3,dim=(10, 10),sign_line=True)

#Box plot diagramms για να δούμε την περιοχή έκφρασης του κάθε γονιδίου για ασθενείς και μη
import matplotlib.pyplot as plt
data_to_plot=[new_df.loc[new_df['Results']=='stroke','GRAP'],new_df.loc[new_df['Results']=='control','GRAP']]
plt.figure(figsize=(10, 6))
plt.title('GRAP')
box = plt.boxplot(data_to_plot,labels=['Stroke(n=82)','Control(n=67)'],patch_artist=True,notch=True)
#plt.show()


data_to_plot=[new_df.loc[new_df['Results']=='stroke','ID3'],new_df.loc[new_df['Results']=='control','ID3']]
plt.figure(figsize=(10, 6))
plt.title('ID3')
box = plt.boxplot(data_to_plot,labels=['Stroke(n=82)','Control(n=67)'],patch_artist=True,notch=True)

data_to_plot=[new_df.loc[new_df['Results']=='stroke','ABCA1'],new_df.loc[new_df['Results']=='control','ABCA1']]
plt.figure(figsize=(10, 6))
plt.title('ABCA1')
box = plt.boxplot(data_to_plot,labels=['Stroke(n=82)','Control(n=67)'],patch_artist=True,notch=True)

data_to_plot=[new_df.loc[new_df['Results']=='stroke','CD79B'],new_df.loc[new_df['Results']=='control','CD79B']]
plt.figure(figsize=(10, 6))
plt.title('CD79B')
box = plt.boxplot(data_to_plot,labels=['Stroke(n=82)','Control(n=67)'],patch_artist=True,notch=True)

data_to_plot=[new_df.loc[new_df['Results']=='stroke','SAP30'],new_df.loc[new_df['Results']=='control','SAP30']]
plt.figure(figsize=(10, 6))
plt.title('SAP30')
box = plt.boxplot(data_to_plot,labels=['Stroke(n=82)','Control(n=67)'],patch_artist=True,notch=True)

data_to_plot=[new_df.loc[new_df['Results']=='stroke','ANKRD22'],new_df.loc[new_df['Results']=='control','ANKRD22']]
plt.figure(figsize=(10, 6))
plt.title('ANKRD22')
box = plt.boxplot(data_to_plot,labels=['Stroke(n=82)','Control(n=67)'],patch_artist=True,notch=True)

from scipy.cluster.hierarchy import dendrogram, linkage
from plotly.offline import init_notebook_mode, iplot
from Bio.Cluster import treecluster 
import plotly.graph_objs as go
import numpy as np
import matplotlib.pyplot as plt
from collections import Counter, defaultdict

dataframe_new=(dataFrame.drop(['Results'],axis=1)).transpose()
list2=dataframe_new.index.to_list()
D=dataframe_new.iloc[:,:].values

Z = linkage(D, method='ward', metric='euclidean')
plt.figure(figsize=(10, 6))
ax = plt.subplot()
plt.subplots_adjust(left=0.07, bottom=0.3, right=0.98, top=0.95,
wspace=0, hspace=0)
plt.xlabel('Genes')
plt.ylabel('Distance')
d=dendrogram(Z, leaf_rotation=90., leaf_font_size=10.)

from scipy.cluster.hierarchy import leaves_list
list=leaves_list(Z)
print(list)
print (len(list))

import tensorflow as tf
import pandas as pd
from sklearn.model_selection import train_test_split
from tensorflow.keras.callbacks import EarlyStopping,LearningRateScheduler
#import keras
from tensorflow.python.keras.layers import Dense,Dropout, Flatten,Conv1D, AveragePooling1D,InputLayer,MaxPooling1D
#from tensorflow.python.keras.optimizers import SGD
from tensorflow.python.keras import Sequential
#from tensorflow.keras.models import Sequential
import numpy as np
#from keras.utils import np_utils
import datetime
from sklearn.model_selection import StratifiedKFold
#from keras import backend as K
from sklearn.metrics import classification_report


columns=[]
attribute_name=[]
columns=[list2[i] for i in list]
print(columns)
data=[]
df=np.transpose(dataframe_new)
for i in (list):
  values=df.iloc[:,i]
  data.append(values)
ds_new=np.transpose(pd.DataFrame(data,columns))

ds_new['Results']=outcome


#print(ds_new)
rows,columns=ds_new.shape

# learning rate schedule
import math
#LearningRate = InitialLearningRate * DropRate^floor(Epoch / EpochDrop),floor=the integer not greater than Epoch/EpochDrop
def step_decay(epoch):
	initial_lrate = 0.01
	drop = 0.5
	epochs_drop = 100.0
	lrate = initial_lrate * math.pow(drop, math.floor((1+epoch)/epochs_drop))
	return lrate
from tensorflow.python.framework.ops import disable_eager_execution

from sklearn import preprocessing
lb = preprocessing.LabelBinarizer()


X=ds_new.drop(['Results'],axis=1)
X=X.values.reshape(X.shape[0],X.shape[1],1)

Y=ds_new['Results']
Y=lb.fit_transform(Y)

model = Sequential()
model.add(Conv1D(filters=64,kernel_size=10, strides=1,activation= 'relu',input_shape=(X.shape[1],1),padding='same'))
model.add(Dropout(0.2))
model.add(MaxPooling1D(pool_size=2))
model.add(Conv1D(64, 10, strides=1,activation= 'relu',padding='same'))
model.add(MaxPooling1D(pool_size=2))
model.add(Dense(units=500, activation='relu'))
model.add(Dense(units=250, activation='relu', name='visualized_layer'))
model.add(Flatten())
model.add(Dropout(0.2))
model.add(Dense(units=134, activation='relu'))
model.add(Dense(units=2, activation = 'softmax'))
lrate = LearningRateScheduler(step_decay)
print(model.summary())
model.compile( loss='sparse_categorical_crossentropy' , optimizer='sgd', metrics=[ 'accuracy' ])

es = EarlyStopping(monitor='val_loss', mode='min', verbose=1, patience=100)

# Κάνω Stratified Cross Validation για την αξιολόγηση του μοντέλου
from sklearn import model_selection
from sklearn.metrics import precision_recall_curve, auc, roc_curve
import matplotlib.pyplot as plt
from scipy import interp


k_fold = StratifiedKFold(n_splits=5, random_state=42, shuffle=True)



cvscores=[]
y_real = []
y_proba = []

mean_tpr = 0.0
mean_fpr = np.linspace(0, 1, 100)
all_tpr = []
model2=model
i=0
for k_train_index, k_test_index in k_fold.split(X, Y):
  history=model.fit(X[k_train_index,:], Y[k_train_index],validation_data=(X[k_test_index,:],Y[k_test_index]) ,epochs=400,batch_size=30,callbacks=[lrate,es])
  probas_ =model.predict_proba(X[k_test_index,:])
  results = model.evaluate(X[k_train_index,:], Y[k_train_index], verbose=0)
  print('train loss,train acc: ',results)
  results = model.evaluate(X[k_test_index,:],Y[k_test_index], batch_size=30)
  print('test loss, test acc:', results)
  cvscores.append(results[1] * 100)
  # Compute ROC curve and area the curve
  fpr, tpr, thresholds = roc_curve(Y[k_test_index], probas_[:, 1])
  mean_tpr += interp(mean_fpr, fpr, tpr)
  mean_tpr[0] = 0.0
  roc_auc = auc(fpr, tpr)
  plt.plot(fpr, tpr, lw=1, label='ROC fold %d (area = %0.2f)' % (i, roc_auc))
  i=i+1

plt.plot([0, 1], [0, 1], '--', color=(0.6, 0.6, 0.6), label='Luck')
mean_tpr /= 5
mean_tpr[-1] = 1.0
mean_auc = auc(mean_fpr, mean_tpr)
plt.plot(mean_fpr, mean_tpr, 'k--',label='Mean ROC (area = %0.2f)' % mean_auc, lw=2)

plt.xlim([-0.05, 1.05])
plt.ylim([-0.05, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver operating characteristic example')
plt.legend(loc="lower right")
plt.show()


val_loss, val_acc = model.evaluate(X, Y)
print('Model accuracy of whole dataset as test dataset',val_acc)
y_pred = model.predict(X, batch_size=10, verbose=1)
y_pred_bool = np.argmax(y_pred, axis=1)
print(classification_report(Y, y_pred_bool))
print("Mean performance of model %.2f%% (+/- %.2f%%)" % (np.mean(cvscores), np.std(cvscores)))